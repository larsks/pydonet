import os, sys, tempfile, zipfile
from pydonet.packet import Packet
from pydonet.message import Message
import optparse

def parse_args():
  parser = optparse.OptionParser()

  parser.add_option('-f', '--filter')
  parser.add_option('-o', '--output-dir')
  parser.add_option('-z', '--zip', action='store_true',
      help='Read packets compressed with Zip.')
  parser.add_option('-v', '--verbose', action='store_true')
  parser.add_option('-k', '--keep', action='store_true',
      help='Do not remove source packets.')

  opts, args = parser.parse_args()
  return opts, args

class StopMessageProcessing (Exception):
  pass

def runfilter(filter, packet, msg):
  state = {
      'disposition': 'keep',
      'messages': []
      }

  def show():
    return 'From: %s, To: %s, Re: %s' % (
        msg.fromUsername, msg.toUsername, msg.subject
    )

  def discard():
    '''Discard a message.'''

    print '  - DISCARD:', show()
    state['disposition'] = 'discard'

  def keep():
    '''Deliver the message normally.  This is the default behavior; you
    would use the keep() command to reverse a previous discard().'''

    print '  - KEEP:', show()
    state['disposition'] = 'keep'

  def stop():
    '''Stop message processing at this point (do not process
    additional rules)'''

    raise StopMessageProcessing()

  def copy(area):
    '''Generate a new copy of the message in the given message
    area.'''

    print '  - COPY (to %s):' % area, show()
    x = Message(data = msg.serialize())
    x.area = area
    state['messages'].append(x)

  def move(area):
    '''Change message area for message.  Needs to change MSGID to
    avoid dupe filters.'''

    print '  - MOVE (to %s):' % area, show()
    msg.body.klines['X-ORIGINAL-AREA:'] = msg.body.area
    msg.body.area = area

  try:
    fd = open(filter)
    exec fd in {
        'M': msg, 'P': packet,
        'discard': discard,
        'copy': copy,
        'move': move,
        'keep': keep,
        'stop': stop,
        'show': show,
        }
  except StopMessageProcessing:
    pass

  return state

def process_packet(P, name, opts):
  print '+ Processing:', name

  (nP, nPname) = tempfile.mkstemp(dir = opts.output_dir)
  os.write(nP, P.serialize())

  icount = 0
  ocount = 0
  for msg in P:
    icount += 1
    area = msg.body.area and '[%s] ' % msg.body.area or ''
    if opts.verbose:
      print '  %s%s -> %s: %s' % (area, msg.fromUsername, msg.toUsername, msg.subject)
    state = runfilter(opts.filter, P, msg)
    if state['disposition'] == 'keep':
      ocount += 1
      os.write(nP, msg.serialize())

    # Write out any new messages that were generated by copy()
    # operations in the filter.
    for msg in state['messages']:
      os.write(nP, msg.serialize())
      ocount += 1

  os.write(nP, '\x00\x00')
  os.close(nP)

  print '  %d messages in, %d messages out.' % (icount, ocount)

  if ocount > 0:
    os.rename(nPname, os.path.join(opts.output_dir, name))
  else:
    print '  Removing %s (no messages)' % name
    os.unlink(nPname)

def main():

  opts, args = parse_args()

  if opts.filter is None:
    print >>sys.stderr, 'ERROR: You must specify a filter.'
    sys.exit(2)

  for arg in args:
    if opts.zip:
      z = zipfile.ZipFile(arg)
      for f in z.namelist():
        P = Packet(data = z.read(f))
        process_packet(P, f, opts)
    else:
      P = Packet(file = arg)
      process_packet(P, os.path.basename(arg), opts)

    if not opts.keep:
      try:
        os.unlink(arg)
      except OSError, detail:
        print >>sys.stderr, 'WARNING: Failed to delete %s: %s' % (arg, detail)

